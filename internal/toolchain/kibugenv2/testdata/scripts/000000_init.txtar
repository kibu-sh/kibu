kibugenv2 $WORK/src ./...
cmp $WORK/exp/billingv1/billingv1.gen.go $WORK/src/billingv1/billingv1.gen.go

-- src/go.mod --
module github.com/example/module

-- src/billingv1/billingv1.spec.go --
package billingv1

import (
	"context"
	"go.temporal.io/sdk/workflow"
)

type AccountStatus string

const (
	AccountStatusUnsubscribed   AccountStatus = "trial"
	AccountStatusSubscribed     AccountStatus = "subscribed"
	AccountStatusPaymentFailed  AccountStatus = "payment_failed"
	AccountStatusPaymentPending AccountStatus = "payment_pending"
	AccountStatusCanceled       AccountStatus = "canceled"
)

type WatchAccountRequest struct{}

type WatchAccountResponse struct {
	Status AccountStatus
}

type ChargePaymentMethodRequest struct {
	Fail bool `json:"fail"`
}

type ChargePaymentMethodResponse struct {
	Success bool `json:"success"`
}

type CustomerSubscriptionsRequest struct{}
type CustomerSubscriptionsResponse struct{}

type SetDiscountRequest struct {
	DiscountCode string `json:"discount_code"`
}

type CancelBillingRequest struct{}

type AttemptPaymentRequest struct {
	Fail bool `json:"fail"`
}

type AttemptPaymentResponse struct {
	Success bool `json:"success"`
}

type GetAccountDetailsRequest struct{}
type GetAccountDetailsResponse struct {
	//Status AccountStatus
}

// Service is the public-facing API for this system
//
//kibu:service public
type Service interface {
	// WatchAccount watches the account status
	//
	//kibu:service:method
	WatchAccount(ctx context.Context, req WatchAccountRequest) (res WatchAccountResponse, err error)
}

// Activities synchronize the workflow state with an external payment gateway
//
//kibu:activity task_queue=payments
type Activities interface {
	// ChargePaymentMethod performs work against another transactional system
	//
	//kibu:activity:method
	ChargePaymentMethod(ctx context.Context, req ChargePaymentMethodRequest) (res ChargePaymentMethodResponse, err error)
}

// CustomerSubscriptionsWorkflow represents a single long-running workflow for a customer
//
//kibu:workflow task_queue=payments
type CustomerSubscriptionsWorkflow interface {
	// Execute initiates a long-running workflow for the customers account
	//
	//kibu:workflow:execute
	Execute(ctx workflow.Context, req CustomerSubscriptionsRequest) (res CustomerSubscriptionsResponse, err error)

	// AttemptPayment attempts to charge the customers payment method
	// the account status will reflect the outcome of the attempt
	//
	//kibu:workflow:update
	AttemptPayment(ctx workflow.Context, req AttemptPaymentRequest) (res AttemptPaymentResponse, err error)

	// SetDiscount sets the discount code for the customer
	//
	//kibu:workflow:signal
	SetDiscount(ctx workflow.Context, req SetDiscountRequest) error

	// CancelBilling sends a signalChannel to cancel the customer's billing process
	// this will end the workflow
	//
	//kibu:workflow:signal
	CancelBilling(ctx workflow.Context, req CancelBillingRequest) error

	// GetAccountDetails returns the current account status
	// should not mutate state, doesn't have context
	// should not call activities (helps enforce determinism)
	//
	//kibu:workflow:query
	GetAccountDetails(req GetAccountDetailsRequest) (res GetAccountDetailsResponse, err error)
}
-- exp/billingv1/billingv1.gen.go --
// Code generated by kibu. DO NOT EDIT.

package billingv1

import (
	"context"
	wire "github.com/google/wire"
	transport "github.com/kibu-sh/kibu/pkg/transport"
	httpx "github.com/kibu-sh/kibu/pkg/transport/httpx"
	temporal "github.com/kibu-sh/kibu/pkg/transport/temporal"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	"time"
)

// compiler assertions
var _ ActivitiesProxy = (*activitiesProxy)(nil)
var _ CustomerSubscriptionsWorkflowChildRun = (*customerSubscriptionsWorkflowChildRun)(nil)
var _ CustomerSubscriptionsWorkflowClient = (*customerSubscriptionsWorkflowClient)(nil)

// system constants
const (
	packageName                                        = "billingv1"
	serviceName                                        = "billingv1.Service"
	serviceWatchAccountName                            = "billingv1.Service.WatchAccount"
	activitiesName                                     = "billingv1.Activities"
	activitiesChargePaymentMethodName                  = "billingv1.Activities.ChargePaymentMethod"
	customerSubscriptionsWorkflowName                  = "billingv1.CustomerSubscriptionsWorkflow"
	customerSubscriptionsWorkflowExecuteName           = "billingv1.CustomerSubscriptionsWorkflow.Execute"
	customerSubscriptionsWorkflowAttemptPaymentName    = "billingv1.CustomerSubscriptionsWorkflow.AttemptPayment"
	customerSubscriptionsWorkflowSetDiscountName       = "billingv1.CustomerSubscriptionsWorkflow.SetDiscount"
	customerSubscriptionsWorkflowCancelBillingName     = "billingv1.CustomerSubscriptionsWorkflow.CancelBilling"
	customerSubscriptionsWorkflowGetAccountDetailsName = "billingv1.CustomerSubscriptionsWorkflow.GetAccountDetails"
)

// signal channel providers
func NewSetDiscountSignalChannel(ctx workflow.Context) temporal.SignalChannel[SetDiscountRequest] {
	return temporal.NewSignalChannel[SetDiscountRequest](ctx, customerSubscriptionsWorkflowSetDiscountName)
}
func NewCancelBillingSignalChannel(ctx workflow.Context) temporal.SignalChannel[CancelBillingRequest] {
	return temporal.NewSignalChannel[CancelBillingRequest](ctx, customerSubscriptionsWorkflowCancelBillingName)
}

// workflow interfaces
type CustomerSubscriptionsWorkflowRun interface {
	WorkflowID() string
	RunID() string
	Get(ctx context.Context) (res CustomerSubscriptionsResponse, err error)
	SetDiscount(ctx context.Context, req SetDiscountRequest) error
	CancelBilling(ctx context.Context, req CancelBillingRequest) error
	GetAccountDetails(ctx context.Context, req GetAccountDetailsRequest) (res GetAccountDetailsResponse, err error)
	AttemptPayment(ctx context.Context, req AttemptPaymentRequest, mods ...temporal.UpdateOptionFunc) (res AttemptPaymentResponse, err error)
	AttemptPaymentAsync(ctx context.Context, req AttemptPaymentRequest, mods ...temporal.UpdateOptionFunc) (res temporal.UpdateHandle[AttemptPaymentResponse], err error)
}
type CustomerSubscriptionsWorkflowChildRun interface {
	WorkflowID() string
	IsReady() bool
	Underlying() workflow.ChildWorkflowFuture
	Get(ctx workflow.Context) (res CustomerSubscriptionsResponse, err error)
	WaitStart(ctx workflow.Context) (*workflow.Execution, error)
	Select(sel workflow.Selector, fn func(CustomerSubscriptionsWorkflowChildRun)) workflow.Selector
	SelectStart(sel workflow.Selector, fn func(CustomerSubscriptionsWorkflowChildRun)) workflow.Selector
	SetDiscount(ctx workflow.Context, req SetDiscountRequest) error
	CancelBilling(ctx workflow.Context, req CancelBillingRequest) error
}
type CustomerSubscriptionsWorkflowExternalRun interface {
	WorkflowID() string
	RunID() string
	RequestCancellation(ctx workflow.Context) error
	SetDiscount(ctx workflow.Context, req SetDiscountRequest) error
	SetDiscountAsync(ctx workflow.Context, req SetDiscountRequest) workflow.Future
	CancelBilling(ctx workflow.Context, req CancelBillingRequest) error
	CancelBillingAsync(ctx workflow.Context, req CancelBillingRequest) workflow.Future
}
type CustomerSubscriptionsWorkflowClient interface {
	GetHandle(ctx context.Context, opts temporal.GetHandleOpts) (CustomerSubscriptionsWorkflowRun, error)
	Execute(ctx context.Context, req CustomerSubscriptionsRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsWorkflowRun, error)
	ExecuteWithSetDiscount(ctx context.Context, req CustomerSubscriptionsRequest, sig SetDiscountRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsWorkflowRun, error)
	ExecuteWithCancelBilling(ctx context.Context, req CustomerSubscriptionsRequest, sig CancelBillingRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsWorkflowRun, error)
}
type CustomerSubscriptionsWorkflowChildClient interface {
	External(opts temporal.GetHandleOpts) CustomerSubscriptionsWorkflowExternalRun
	Execute(ctx workflow.Context, req CustomerSubscriptionsRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsResponse, error)
	ExecuteAsync(ctx workflow.Context, req CustomerSubscriptionsRequest, mods ...temporal.WorkflowOptionFunc) CustomerSubscriptionsWorkflowChildRun
}
type CustomerSubscriptionsWorkflowInput struct {
	Request              CustomerSubscriptionsRequest
	SetDiscountChannel   temporal.SignalChannel[SetDiscountRequest]
	CancelBillingChannel temporal.SignalChannel[CancelBillingRequest]
}
type CustomerSubscriptionsWorkflowFactory func(input *CustomerSubscriptionsWorkflowInput) (CustomerSubscriptionsWorkflow, error)
type CustomerSubscriptionsWorkflowController struct {
	Factory CustomerSubscriptionsWorkflowFactory
}
type WorkflowsProxy interface {
	CustomerSubscriptionsWorkflow() CustomerSubscriptionsWorkflowChildClient
}
type WorkflowsClient interface {
	CustomerSubscriptionsWorkflow() CustomerSubscriptionsWorkflowClient
}

// workflow implementations
type workflowsClient struct {
	client client.Client
}

func (w *workflowsClient) CustomerSubscriptionsWorkflow() CustomerSubscriptionsWorkflowClient {
	return &customerSubscriptionsWorkflowClient{client: w.client}
}

type customerSubscriptionsWorkflowClient struct {
	client client.Client
}

func (c *customerSubscriptionsWorkflowClient) Execute(ctx context.Context, req CustomerSubscriptionsRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsWorkflowRun, error) {
	options := temporal.NewWorkflowOptionsBuilder().WithProvidersWhenSupported(req).WithOptions(mods...).WithTaskQueue(packageName).AsStartOptions()

	we, err := c.client.ExecuteWorkflow(ctx, options, customerSubscriptionsWorkflowName, req)
	if err != nil {
		return nil, err
	}

	return &customerSubscriptionsWorkflowRun{client: c.client, workflowRun: we}, nil
}
func (c *customerSubscriptionsWorkflowClient) GetHandle(ctx context.Context, ref temporal.GetHandleOpts) (CustomerSubscriptionsWorkflowRun, error) {
	return &customerSubscriptionsWorkflowRun{client: c.client, workflowRun: c.client.GetWorkflow(ctx, ref.WorkflowID, ref.RunID)}, nil
}
func (c *customerSubscriptionsWorkflowClient) ExecuteWithSetDiscount(ctx context.Context, req CustomerSubscriptionsRequest, sig SetDiscountRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsWorkflowRun, error) {
	options := temporal.NewWorkflowOptionsBuilder().WithProvidersWhenSupported(req).WithOptions(mods...).WithTaskQueue(packageName).AsStartOptions()

	run, err := c.client.SignalWithStartWorkflow(ctx, options.ID, customerSubscriptionsWorkflowSetDiscountName, sig, options, customerSubscriptionsWorkflowName, req)
	if err != nil {
		return nil, err
	}

	return &customerSubscriptionsWorkflowRun{client: c.client, workflowRun: run}, nil
}
func (c *customerSubscriptionsWorkflowClient) ExecuteWithCancelBilling(ctx context.Context, req CustomerSubscriptionsRequest, sig CancelBillingRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsWorkflowRun, error) {
	options := temporal.NewWorkflowOptionsBuilder().WithProvidersWhenSupported(req).WithOptions(mods...).WithTaskQueue(packageName).AsStartOptions()

	run, err := c.client.SignalWithStartWorkflow(ctx, options.ID, customerSubscriptionsWorkflowCancelBillingName, sig, options, customerSubscriptionsWorkflowName, req)
	if err != nil {
		return nil, err
	}

	return &customerSubscriptionsWorkflowRun{client: c.client, workflowRun: run}, nil
}

type workflowsProxy struct{}

func (w *workflowsProxy) CustomerSubscriptionsWorkflow() CustomerSubscriptionsWorkflowChildClient {
	return &customerSubscriptionsWorkflowChildClient{}
}

type customerSubscriptionsWorkflowChildClient struct{}

func (c *customerSubscriptionsWorkflowChildClient) Execute(ctx workflow.Context, req CustomerSubscriptionsRequest, mods ...temporal.WorkflowOptionFunc) (CustomerSubscriptionsResponse, error) {
	return c.ExecuteAsync(ctx, req, mods...).Get(ctx)
}
func (c *customerSubscriptionsWorkflowChildClient) ExecuteAsync(ctx workflow.Context, req CustomerSubscriptionsRequest, mods ...temporal.WorkflowOptionFunc) CustomerSubscriptionsWorkflowChildRun {
	options := temporal.NewWorkflowOptionsBuilder().WithProvidersWhenSupported(req).WithOptions(mods...).WithTaskQueue(packageName).AsChildOptions()
	ctx = workflow.WithChildOptions(ctx, options)
	childFuture := workflow.ExecuteChildWorkflow(ctx, customerSubscriptionsWorkflowName, req)
	return &customerSubscriptionsWorkflowChildRun{childFuture: childFuture}
}
func (c *customerSubscriptionsWorkflowChildClient) External(ref temporal.GetHandleOpts) CustomerSubscriptionsWorkflowExternalRun {
	return &customerSubscriptionsWorkflowExternalRun{workflowID: ref.WorkflowID, runID: ref.RunID}
}

type customerSubscriptionsWorkflowChildRun struct {
	workflowId  string
	childFuture workflow.ChildWorkflowFuture
}

func (r *customerSubscriptionsWorkflowChildRun) WorkflowID() string {
	return r.workflowId
}
func (r *customerSubscriptionsWorkflowChildRun) IsReady() bool {
	return r.childFuture.IsReady()
}
func (r *customerSubscriptionsWorkflowChildRun) Underlying() workflow.ChildWorkflowFuture {
	return r.childFuture
}
func (r *customerSubscriptionsWorkflowChildRun) Get(ctx workflow.Context) (CustomerSubscriptionsResponse, error) {
	var result CustomerSubscriptionsResponse
	err := r.childFuture.Get(ctx, &result)
	return result, err
}
func (r *customerSubscriptionsWorkflowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	err := r.childFuture.GetChildWorkflowExecution().Get(ctx, &exec)
	if err != nil {
		return nil, err
	}
	return &exec, nil
}
func (r *customerSubscriptionsWorkflowChildRun) Select(sel workflow.Selector, fn func(CustomerSubscriptionsWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.childFuture, func(workflow.Future) {
		fn(r)
	})
}
func (r *customerSubscriptionsWorkflowChildRun) SelectStart(sel workflow.Selector, fn func(CustomerSubscriptionsWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.childFuture.GetChildWorkflowExecution(), func(workflow.Future) {
		fn(r)
	})
}
func (r *customerSubscriptionsWorkflowChildRun) SetDiscount(ctx workflow.Context, req SetDiscountRequest) error {
	return r.childFuture.SignalChildWorkflow(ctx, customerSubscriptionsWorkflowSetDiscountName, req).Get(ctx, nil)
}
func (r *customerSubscriptionsWorkflowChildRun) CancelBilling(ctx workflow.Context, req CancelBillingRequest) error {
	return r.childFuture.SignalChildWorkflow(ctx, customerSubscriptionsWorkflowCancelBillingName, req).Get(ctx, nil)
}

type customerSubscriptionsWorkflowExternalRun struct {
	workflowID string
	runID      string
}

func (r *customerSubscriptionsWorkflowExternalRun) WorkflowID() string {
	return r.workflowID
}
func (r *customerSubscriptionsWorkflowExternalRun) RunID() string {
	return r.runID
}
func (r *customerSubscriptionsWorkflowExternalRun) RequestCancellation(ctx workflow.Context) error {
	return workflow.RequestCancelExternalWorkflow(ctx, r.workflowID, r.runID).Get(ctx, nil)
}
func (r *customerSubscriptionsWorkflowExternalRun) SetDiscount(ctx workflow.Context, req SetDiscountRequest) error {
	return workflow.SignalExternalWorkflow(ctx, r.workflowID, r.runID, customerSubscriptionsWorkflowSetDiscountName, req).Get(ctx, nil)
}
func (r *customerSubscriptionsWorkflowExternalRun) SetDiscountAsync(ctx workflow.Context, req SetDiscountRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, r.workflowID, r.runID, customerSubscriptionsWorkflowSetDiscountName, req)
}
func (r *customerSubscriptionsWorkflowExternalRun) CancelBilling(ctx workflow.Context, req CancelBillingRequest) error {
	return workflow.SignalExternalWorkflow(ctx, r.workflowID, r.runID, customerSubscriptionsWorkflowCancelBillingName, req).Get(ctx, nil)
}
func (r *customerSubscriptionsWorkflowExternalRun) CancelBillingAsync(ctx workflow.Context, req CancelBillingRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, r.workflowID, r.runID, customerSubscriptionsWorkflowCancelBillingName, req)
}

type customerSubscriptionsWorkflowRun struct {
	client      client.Client
	workflowRun client.WorkflowRun
}

func (r *customerSubscriptionsWorkflowRun) WorkflowID() string {
	return r.workflowRun.GetID()
}
func (r *customerSubscriptionsWorkflowRun) RunID() string {
	return r.workflowRun.GetRunID()
}
func (r *customerSubscriptionsWorkflowRun) Get(ctx context.Context) (CustomerSubscriptionsResponse, error) {
	var result CustomerSubscriptionsResponse
	err := r.workflowRun.Get(ctx, &result)
	return result, err
}
func (r *customerSubscriptionsWorkflowRun) AttemptPayment(ctx context.Context, req AttemptPaymentRequest, mods ...temporal.UpdateOptionFunc) (AttemptPaymentResponse, error) {
	handle, err := r.AttemptPaymentAsync(ctx, req, mods...)
	if err != nil {
		return AttemptPaymentResponse{}, err
	}
	return handle.Get(ctx)
}
func (r *customerSubscriptionsWorkflowRun) AttemptPaymentAsync(ctx context.Context, req AttemptPaymentRequest, mods ...temporal.UpdateOptionFunc) (temporal.UpdateHandle[AttemptPaymentResponse], error) {
	options := temporal.NewUpdateOptionsBuilder().WithUpdateName(customerSubscriptionsWorkflowAttemptPaymentName).WithWorkflowID(r.WorkflowID()).WithRunID(r.RunID()).WithProvidersWhenSupported(req).WithOptions(mods...).WithArgs(req).Build()

	handle, err := r.client.UpdateWorkflow(ctx, options)
	if err != nil {
		return nil, err
	}

	return temporal.NewUpdateHandle[AttemptPaymentResponse](handle), nil
}
func (r *customerSubscriptionsWorkflowRun) GetAccountDetails(ctx context.Context, req GetAccountDetailsRequest) (GetAccountDetailsResponse, error) {
	queryResponse, err := r.client.QueryWorkflow(ctx, r.WorkflowID(), r.RunID(), customerSubscriptionsWorkflowGetAccountDetailsName, req)

	if err != nil {
		return GetAccountDetailsResponse{}, err
	}

	var result GetAccountDetailsResponse
	err = queryResponse.Get(&result)
	return result, err
}
func (r *customerSubscriptionsWorkflowRun) SetDiscount(ctx context.Context, req SetDiscountRequest) error {
	return r.client.SignalWorkflow(ctx, r.WorkflowID(), r.RunID(), customerSubscriptionsWorkflowSetDiscountName, req)
}
func (r *customerSubscriptionsWorkflowRun) CancelBilling(ctx context.Context, req CancelBillingRequest) error {
	return r.client.SignalWorkflow(ctx, r.WorkflowID(), r.RunID(), customerSubscriptionsWorkflowCancelBillingName, req)
}

// activity interfaces
type ActivitiesProxy interface {
	ChargePaymentMethod(ctx workflow.Context, req ChargePaymentMethodRequest, mods ...temporal.ActivityOptionFunc) (ChargePaymentMethodResponse, error)
	ChargePaymentMethodAsync(ctx workflow.Context, req ChargePaymentMethodRequest, mods ...temporal.ActivityOptionFunc) temporal.Future[ChargePaymentMethodResponse]
}
type activitiesProxy struct{}

func (a *activitiesProxy) ChargePaymentMethod(ctx workflow.Context, req ChargePaymentMethodRequest, mods ...temporal.ActivityOptionFunc) (res ChargePaymentMethodResponse, err error) {
	return a.ChargePaymentMethodAsync(ctx, req, mods...).Get(ctx)
}
func (a *activitiesProxy) ChargePaymentMethodAsync(ctx workflow.Context, req ChargePaymentMethodRequest, mods ...temporal.ActivityOptionFunc) temporal.Future[ChargePaymentMethodResponse] {
	options := temporal.NewActivityOptionsBuilder().WithStartToCloseTimeout(time.Second * 30).WithTaskQueue(packageName).WithProvidersWhenSupported(req).WithOptions(mods...).Build()
	ctx = workflow.WithActivityOptions(ctx, options)
	future := workflow.ExecuteActivity(ctx, activitiesChargePaymentMethodName, req)
	return temporal.NewFuture[ChargePaymentMethodResponse](future)
}
func (wk *CustomerSubscriptionsWorkflowController) Execute(ctx workflow.Context, req CustomerSubscriptionsRequest) (res CustomerSubscriptionsResponse, err error) {
	input := &CustomerSubscriptionsWorkflowInput{
		Request:              req,
		SetDiscountChannel:   NewSetDiscountSignalChannel(ctx),
		CancelBillingChannel: NewCancelBillingSignalChannel(ctx),
	}
	wf, err := wk.Factory(input)
	if err != nil {
		return
	}
	if err = workflow.SetQueryHandler(ctx, customerSubscriptionsWorkflowGetAccountDetailsName, wf.GetAccountDetails); err != nil {
		return
	}
	if err = workflow.SetUpdateHandlerWithOptions(ctx, customerSubscriptionsWorkflowAttemptPaymentName, wf.AttemptPayment, workflow.UpdateHandlerOptions{}); err != nil {
		return
	}
	return wf.Execute(ctx, req)
}
func (wk *CustomerSubscriptionsWorkflowController) Build(registry worker.WorkflowRegistry) {
	registry.RegisterWorkflowWithOptions(wk.Execute, workflow.RegisterOptions{
		DisableAlreadyRegisteredCheck: true,
		Name:                          customerSubscriptionsWorkflowName,
	})
}

type ActivitiesController struct {
	Activities Activities
}

func (act *ActivitiesController) Build(registry worker.ActivityRegistry) {
	registry.RegisterActivityWithOptions(act.Activities.ChargePaymentMethod, activity.RegisterOptions{
		DisableAlreadyRegisteredCheck: true,
		Name:                          activitiesChargePaymentMethodName,
	})
}

//kibu:provider group=httpx.HandlerFactory
type ServiceController struct {
	Service Service
}

func (svc *ServiceController) Build() []*httpx.Handler {
	var handlers []*httpx.Handler
	handlers = append(handlers, httpx.NewHandler("/billingv1/Service/WatchAccount", transport.NewEndpoint(svc.Service.WatchAccount)).WithMethods("POST"))
	return handlers
}

//kibu:provider group=WorkerFactory import=github.com/kibu-sh/kibu/pkg/transport/temporal
type WorkerController struct {
	Client                                  client.Client
	Options                                 worker.Options
	ActivitiesController                    ActivitiesController
	CustomerSubscriptionsWorkflowController CustomerSubscriptionsWorkflowController
}

func (wc *WorkerController) Build() worker.Worker {
	wk := worker.New(wc.Client, packageName, wc.Options)
	wc.ActivitiesController.Build(wk)
	wc.CustomerSubscriptionsWorkflowController.Build(wk)
	return wk
}
func NewActivitiesProxy() ActivitiesProxy {
	return &activitiesProxy{}
}
func NewWorkflowsProxy() WorkflowsProxy {
	return &workflowsProxy{}
}
func NewWorkflowsClient(client client.Client) WorkflowsClient {
	return &workflowsClient{client: client}
}

//kibu:provider
var GenWireSet = wire.NewSet(
	NewActivitiesProxy,
	NewWorkflowsProxy,
	NewWorkflowsClient,
	wire.Struct(new(WorkerController), "*"),
	wire.Struct(new(ServiceController), "*"),
	wire.Struct(new(ActivitiesController), "*"),
	wire.Struct(new(CustomerSubscriptionsWorkflowController), "*"),
)
