package kibuwire

import (
	"github.com/dave/jennifer/jen"
	"github.com/kibu-sh/kibu/internal/toolchain/modspecv2"
	"github.com/kibu-sh/kibu/internal/toolchain/pipeline"
	"github.com/rogpeppe/go-internal/testscript"
	"github.com/samber/lo"
	"github.com/stretchr/testify/require"
	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/analysistest"
	"path/filepath"
	"strings"
	"testing"
)

func TestAnalyzer(t *testing.T) {
	testdata := analysistest.TestData()
	analyzerPath := filepath.Join(testdata, "analyzer")
	results := analysistest.Run(t, analyzerPath,
		Analyzer, "./...")

	artifact, ok := results[0].Result.(*Artifact)
	providers := artifact.Providers
	require.True(t, ok)
	require.NotNil(t, providers)
	require.Equal(t, 3, providers.Len())

	grouped := providers.GroupBy(GroupByFQN())
	require.Equal(t, grouped.Len(), 1, "should have 1 group")
	httpHandlers, ok := grouped.Get("github.com/kibu-sh/kibu/pkg/transport/httpx.HandlerFactory")
	require.True(t, ok)
	require.NotNil(t, httpHandlers)
	require.Equal(t, httpHandlers.Len(), 1)

	require.Equal(t, httpHandlers[0].Group.Name, "HandlerFactory")
	require.Equal(t, httpHandlers[0].Group.Import, "github.com/kibu-sh/kibu/pkg/transport/httpx")
}

func ResolveDir(t *testing.T, rel string) string {
	t.Helper()
	abs, err := filepath.Abs(rel)
	if err != nil {
		t.Fatal(err)
	}
	return abs
}

func TestGenerator(t *testing.T) {
	testdata := ResolveDir(t, "testdata")
	scripts := filepath.Join(testdata, "scripts")

	testscript.Run(t, testscript.Params{
		Dir:      scripts,
		TestWork: true,
		Cmds: map[string]func(ts *testscript.TestScript, neg bool, args []string){
			"kibuwire": func(ts *testscript.TestScript, neg bool, args []string) {
				root := args[0]
				genDir := args[1]
				patterns := args[2:]

				if filepath.IsAbs(genDir) {
					genDir = strings.TrimPrefix(genDir, root)
				}

				cfg := pipeline.ConfigDefaults().
					WithDir(root).
					WithPatterns(patterns).
					WithAnalyzers([]*analysis.Analyzer{Analyzer})

				results, err := pipeline.Run(cfg)
				ts.Check(err)

				providerArtifacts := modspecv2.GatherResults[*Artifact](results)
				wiremod := buildKibuWireModule(genDir, providerArtifacts)
				artifacts := modspecv2.GatherResults[modspecv2.Artifact](results)
				artifacts = append(artifacts, wiremod)
				_, err = modspecv2.SaveArtifacts(root, artifacts)
			},
		},
	})
}

var _ modspecv2.Artifact = (*KibuwireModule)(nil)

type KibuwireModule struct {
	file *jen.File
	out  string
}

func (k *KibuwireModule) File() *jen.File {
	return k.file
}

func (k *KibuwireModule) OutputPath() string {
	return filepath.Join(k.out, "kibuwire/kibuwire.gen.go")
}

func buildKibuWireModule(outDir string, artifacts []*Artifact) modspecv2.Artifact {
	var module = &KibuwireModule{
		out:  outDir,
		file: jen.NewFile("kibuwire"),
	}

	module.file.HeaderComment("Code generated by kibu. DO NOT EDIT.")
	providers := lo.Reduce(artifacts, func(list ProviderList, a *Artifact, _ int) ProviderList {
		return append(list, a.Providers...)
	}, ProviderList{})

	buildGroupedProviderSet(module.file, providers)
	buildSuperSet(module.file, providers)

	return module
}

// groupQualName returns the fully qualified name of the group interface
// github.com/kibu-sh/kibu/pkg/transport/httpx.HandlerFactory → httpx.HandlerFactory
func groupQualName(group *Group) *jen.Statement {
	return jen.Qual(group.Import, group.Name)
}

// groupQualParam returns the fully qualified name of the group interface as a slice
// github.com/kibu-sh/kibu/pkg/transport/httpx.HandlerFactory → []httpx.HandlerFactory
func groupQualParam(group *Group) *jen.Statement {
	return jen.Index().Add(groupQualName(group))
}

// groupProviderName returns the name of the group provider
// github.com/kibu-sh/kibu/pkg/transport/httpx.HandlerFactory → HttpxHandlerFactoryGroup
func groupProviderName(group *Group) string {
	return lo.PascalCase(groupQualName(group).GoString()) + "Group"
}

// providerQualName returns the fully qualified name of the provider
// example.com/billingv1.ServiceController → billingv1.ServiceController
func providerQualName(provider *Provider) *jen.Statement {
	return jen.Qual(provider.GoPackage.Path(), provider.SymbolName())
}

// providerQualParam returns the fully qualified name of the provider as a pascal case field name
// example.com/billingv1.ServiceController → Billingv1ServiceController
func groupedProviderFieldName(provider *Provider) string {
	return lo.PascalCase(providerQualName(provider).GoString())
}

// groupProviderFuncName returns the name of the group provider function
// github.com/kibu-sh/kibu/pkg/transport/httpx.HandlerFactory → HttpxHandlerFactoryGroupProvider
func groupProviderFuncName(group *Group) string {
	return lo.PascalCase(groupQualName(group).GoString()) + "Provider"
}

func buildGroupedProviderSet(f *jen.File, providers ProviderList) {
	grouped := providers.GroupBy(GroupByFQN())

	for key := range grouped.KeysFromOldest() {
		groupedList, _ := grouped.Get(key)
		group := groupedList[0].Group
		f.Type().Id(groupProviderName(group)).StructFunc(func(g *jen.Group) {
			for _, provider := range groupedList {
				g.Id(groupedProviderFieldName(provider)).Add(providerQualName(provider))
			}
		})

		f.Func().Id(groupProviderFuncName(group)).Params(
			jen.Id("group").Op("*").Id(groupProviderName(group)),
		).Params(groupQualParam(group)).BlockFunc(func(g *jen.Group) {
			g.ReturnFunc(func(g *jen.Group) {
				g.Add(groupQualParam(group)).CustomFunc(modspecv2.MultiLineCurly(), func(g *jen.Group) {
					for _, provider := range groupedList {
						g.Id("group").Dot(groupedProviderFieldName(provider))
					}
				})
			})
		})
	}

	f.Var().Id("GroupSet").Op("=").Qual(wireImportName, "NewSet").CustomFunc(modspecv2.MultiLineParen(), func(g *jen.Group) {
		for key := range grouped.KeysFromOldest() {
			groupedList, _ := grouped.Get(key)
			group := groupedList[0].Group
			g.Qual(wireImportName, "Struct").Call(jen.New(jen.Id(groupProviderName(group))), jen.Lit("*"))
			g.Id(groupProviderFuncName(group))
		}
	})
}

func buildSuperSet(f *jen.File, providers ProviderList) {
	f.Var().Id("SuperSet").Op("=").Qual(wireImportName, "NewSet").CustomFunc(modspecv2.MultiLineParen(), func(g *jen.Group) {
		// includes the group set
		g.Id("GroupSet")

		for _, provider := range providers.Filter(FilterUngrouped) {
			g.Qual(provider.GoPackage.Path(), "WireSet")
		}
	})
}

func FilterUngrouped(p *Provider) bool {
	return p.Group == nil
}
