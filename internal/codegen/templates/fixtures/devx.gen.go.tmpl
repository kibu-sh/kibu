// Code generated by devx. DO NOT EDIT.

package {{ .Name }}

import (
	"time"
    "context"
	"go.temporal.io/sdk/activity"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"go.temporal.io/sdk/workflow"
	"github.com/gofiber/fiber/v2"
)

{{ $worker := .Worker }}
{{- $hasWorkflows := (len .Worker.Workflows) -}}
{{- $hasActivities := (len .Worker.Activities) -}}
{{- $hasServiceMethods := (len .Service.Methods) -}}


{{ range .Types -}}
type {{ .Name }} struct {
	{{- range .Fields }}
	{{ .Name }} {{ .Type }} `json:"{{ .Name | to_snake }}"`
	{{- end }}
}
{{ end }}


{{- if $hasWorkflows }}
type WorkflowClient struct{}
{{ end }}

{{- if $hasActivities }}
type ActivityClient struct{}


type Future[T any] struct {
	tf workflow.Future
}

func (f *Future[T]) IsReady() bool {
	return f.tf.IsReady()
}

func (f *Future[T]) Get(ctx workflow.Context) (res T, err error) {
	err = f.tf.Get(ctx, &res)
	return
}
{{ end }}


{{ range .Worker.Activities }}
func (ac *ActivityClient) {{.Name}}(ctx workflow.Context, req {{.Request.Name}}) Future[{{.Response.Name}}] {
	return Future[{{.Response.Name}}]{
		workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, workflow.ActivityOptions{
			TaskQueue: "{{ $worker.TaskQueue }}",
			StartToCloseTimeout: 10 * time.Second,
		}), "{{.Name}}", req),
	}
}
{{end}}


{{ if or $hasWorkflows $hasActivities }}
func NewWorker (c client.Client) (wrk worker.Worker, err error) {
	wrk = worker.New(c, "{{ .Worker.TaskQueue }}", worker.Options{})

	{{- if $hasWorkflows }}
	wf, err := NewWorkflows()
	if err != nil {
		return
	}
	{{ end }}

	{{- if $hasActivities }}
	act, err := NewActivities()
	if err != nil {
		return
	}
	{{ end }}

	{{ range .Worker.Workflows -}}
	wrk.RegisterWorkflowWithOptions(wf.{{.Name }}, workflow.RegisterOptions{
		Name: "{{ .Name }}",
	})
	{{- end }}

	{{ range .Worker.Activities -}}
	wrk.RegisterActivityWithOptions(act.{{ .Name }}, activity.RegisterOptions{
		Name: "{{ .Name }}",
	})
	{{- end }}

	return
}
{{ end }}


type ServiceHandler[T any, R any] func(ctx context.Context, req T) (res R, err error)

func NewServiceHandler[T any, R any](h ServiceHandler[T, R]) fiber.Handler {
	return func(ctx *fiber.Ctx) error {
		var req T
		if err := ctx.BodyParser(&req); err != nil {
			return err
		}

		res, err := h(ctx.Context(), req)
		if err != nil {
			return err
		}

		return ctx.JSON(res)
	}
}


func NewHTTPTransport() (server *fiber.App, err error) {
	server = fiber.New()
	svc, err := NewService()
	if err != nil {
		return
	}

	{{ range .Service.Methods -}}
	server.{{ .Transports.HTTP.Method | to_camel }}("{{.Transports.HTTP.Path}}", NewServiceHandler[{{.Request.Name}}, {{.Response.Name}}](svc.{{.Name}}))
	{{ end}}

	return
}
